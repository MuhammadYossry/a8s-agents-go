diff --git a/core/agents_loader.go b/core/agents_loader.go
index ee1195e..5a0f042 100644
--- a/core/agents_loader.go
+++ b/core/agents_loader.go
@@ -88,6 +88,8 @@ func (l *AgentLoader) validateAgentDefinition(def *AgentDefinition) error {
 		return fmt.Errorf("missing base URL")
 	}
 	for _, action := range def.Actions {
+		// XXX: I should use def.BaseURL only if action.BaseURL is not provided
+		action.BaseURL = def.BaseURL
 		if err := l.validateAction(action); err != nil {
 			return fmt.Errorf("invalid action %s: %w", action.Name, err)
 		}
diff --git a/core/executor.go b/core/executor.go
index 5391a4c..a367144 100644
--- a/core/executor.go
+++ b/core/executor.go
@@ -7,7 +7,10 @@ import (
 	"encoding/json"
 	"fmt"
 	"io"
+	"log"
 	"net/http"
+	url2 "net/url"
+	"strings"
 	"time"
 
 	"github.com/Relax-N-Tax/AgentNexus/internal/agents"
@@ -133,15 +136,15 @@ func (e *TaskExecutor) findActionForTask(ctx context.Context, task *types.Task)
 
 func (e *TaskExecutor) Execute(ctx context.Context, task *types.Task) (*types.TaskResult, error) {
 	// Handle internal agents differently
-	if e.AgentDef.Type != "external" {
-		// For internal agents, we might want to implement different logic
-		// For now, just return success
-		return &types.TaskResult{
-			TaskID:     task.ID,
-			Success:    true,
-			FinishedAt: time.Now(),
-		}, nil
-	}
+	// if e.AgentDef.Type != "external" {
+	// 	// For internal agents, we might want to implement different logic
+	// 	// For now, just return success
+	// 	return &types.TaskResult{
+	// 		TaskID:     task.ID,
+	// 		Success:    true,
+	// 		FinishedAt: time.Now(),
+	// 	}, nil
+	// }
 
 	// Find appropriate action
 	action, err := e.findActionForTask(ctx, task)
@@ -159,11 +162,28 @@ func (e *TaskExecutor) Execute(ctx context.Context, task *types.Task) (*types.Ta
 }
 
 func (e *TaskExecutor) executeAction(ctx context.Context, task *types.Task, action types.Action) (*types.TaskResult, error) {
-	url := fmt.Sprintf("%s%s", e.AgentDef.BaseURL, action.Path)
+	baseURL := strings.TrimRight(e.AgentDef.BaseURL, "/")
+	if baseURL == "localhost" || strings.HasPrefix(baseURL, "localhost:") {
+		baseURL = "http://" + baseURL
+	}
+	if !strings.HasPrefix(baseURL, "http://") && !strings.HasPrefix(baseURL, "https://") {
+		baseURL = "http://" + baseURL
+	}
+
+	// Ensure path starts with a single slash
+	path := "/" + strings.TrimLeft(action.Path, "/")
+
+	url := baseURL + path
+	log.Printf("Constructed URL for task %s: %s", task.ID, url)
+
+	// Create a copy of the action with the properly formatted URL
+	actionCopy := action
+	actionCopy.BaseURL = baseURL
 
 	// Prepare request with proper error handling
-	req, err := e.prepareRequest(ctx, task, action, url)
+	req, err := e.prepareRequest(ctx, task, actionCopy, url)
 	if err != nil {
+		log.Printf("Error preparing request for task %s: %v", task.ID, err)
 		return &types.TaskResult{
 			TaskID:     task.ID,
 			Success:    false,
@@ -172,6 +192,20 @@ func (e *TaskExecutor) executeAction(ctx context.Context, task *types.Task, acti
 		}, nil
 	}
 
+	// Log request details
+	if req.Body != nil {
+		bodyBytes, err := io.ReadAll(req.Body)
+		if err != nil {
+			log.Printf("Error reading request body for task %s: %v", task.ID, err)
+		} else {
+			// Restore the body for the actual request
+			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
+			log.Printf("Request payload for task %s: %s", task.ID, string(bodyBytes))
+		}
+	} else {
+		log.Printf("Warning: Request body is nil for task %s", task.ID)
+	}
+
 	// Execute request with retries
 	var resp *http.Response
 	var lastErr error
@@ -179,8 +213,10 @@ func (e *TaskExecutor) executeAction(ctx context.Context, task *types.Task, acti
 
 	for attempt := 0; attempt < maxRetries; attempt++ {
 		if attempt > 0 {
+			log.Printf("Retry attempt %d/%d for task %s", attempt+1, maxRetries, task.ID)
 			select {
 			case <-ctx.Done():
+				log.Printf("Task %s cancelled during retry attempt %d", task.ID, attempt+1)
 				return &types.TaskResult{
 					TaskID:     task.ID,
 					Success:    false,
@@ -197,9 +233,11 @@ func (e *TaskExecutor) executeAction(ctx context.Context, task *types.Task, acti
 			break
 		}
 		lastErr = err
+		log.Printf("Request attempt %d failed for task %s: %v", attempt+1, task.ID, err)
 	}
 
 	if err != nil {
+		log.Printf("All retry attempts failed for task %s: %v", task.ID, lastErr)
 		return &types.TaskResult{
 			TaskID:     task.ID,
 			Success:    false,
@@ -207,28 +245,38 @@ func (e *TaskExecutor) executeAction(ctx context.Context, task *types.Task, acti
 			FinishedAt: time.Now(),
 		}, nil
 	}
+
 	defer resp.Body.Close()
+	log.Printf("Received response with status %d for task %s", resp.StatusCode, task.ID)
 
 	// Handle response
 	result, err := e.handleResponse(resp, task)
 	if err != nil {
+		log.Printf("Error handling response for task %s: %v", task.ID, err)
 		return &types.TaskResult{
-			TaskID:  task.ID,
-			Success: false,
-			Error:   fmt.Sprintf("response handling failed: %v", err),
-			// StartedAt:  startTime,
+			TaskID:     task.ID,
+			Success:    false,
+			Error:      fmt.Sprintf("response handling failed: %v", err),
 			FinishedAt: time.Now(),
 		}, nil
 	}
 
-	// Add timing information
-	// result.StartedAt = startTime
-	result.FinishedAt = time.Now()
+	if !result.Success {
+		log.Printf("Task %s completed but unsuccessful: %s", task.ID, result.Error)
+	} else {
+		log.Printf("Successfully executed task %s", task.ID)
+	}
 
+	result.FinishedAt = time.Now()
 	return result, nil
 }
 
 func (e *TaskExecutor) prepareRequest(ctx context.Context, task *types.Task, action types.Action, url string) (*http.Request, error) {
+	// Validate URL before proceeding
+	if _, err := url2.Parse(url); err != nil {
+		return nil, fmt.Errorf("invalid URL %s: %v", url, err)
+	}
+
 	var payload []byte
 	var err error
 
@@ -251,18 +299,6 @@ func (e *TaskExecutor) prepareRequest(ctx context.Context, task *types.Task, act
 		payload = task.Payload
 	}
 
-	// Validate payload
-	var reqBody map[string]interface{}
-	if err := json.Unmarshal(payload, &reqBody); err != nil {
-		return nil, fmt.Errorf("invalid payload JSON: %w", err)
-	}
-
-	// Validate against schema
-	parser := NewSchemaParser(action)
-	if err := parser.ValidateAndPrepareRequest(reqBody); err != nil {
-		return nil, fmt.Errorf("payload validation failed: %w", err)
-	}
-
 	// Create request
 	req, err := http.NewRequestWithContext(ctx, action.Method, url, bytes.NewBuffer(payload))
 	if err != nil {
@@ -277,29 +313,35 @@ func (e *TaskExecutor) prepareRequest(ctx context.Context, task *types.Task, act
 func (e *TaskExecutor) handleResponse(resp *http.Response, task *types.Task) (*types.TaskResult, error) {
 	body, err := io.ReadAll(resp.Body)
 	if err != nil {
+		log.Printf("Error reading response body for task %s: %v", task.ID, err)
 		return nil, fmt.Errorf("reading response body: %w", err)
 	}
 
 	// Handle empty response
 	if len(body) == 0 {
+		log.Printf("Empty response body received for task %s", task.ID)
 		return nil, fmt.Errorf("empty response body")
 	}
 
 	// Handle non-200 responses
 	if resp.StatusCode != http.StatusOK {
+		errorMsg := fmt.Sprintf("request failed with status %d: %s", resp.StatusCode, string(body))
+		log.Printf("Request failed for task %s: %s", task.ID, errorMsg)
 		return &types.TaskResult{
 			TaskID:  task.ID,
 			Success: false,
-			Error:   fmt.Sprintf("request failed with status %d: %s", resp.StatusCode, string(body)),
+			Error:   errorMsg,
 		}, nil
 	}
 
 	// Validate response format
 	var response map[string]interface{}
 	if err := json.Unmarshal(body, &response); err != nil {
+		log.Printf("Invalid JSON response for task %s: %v", task.ID, err)
 		return nil, fmt.Errorf("invalid response JSON: %w", err)
 	}
 
+	log.Printf("Successfully completed task %s with status %d", task.ID, resp.StatusCode)
 	return &types.TaskResult{
 		TaskID:  task.ID,
 		Success: true,
diff --git a/core/schema.go b/core/schema.go
index 468be39..b6fd655 100644
--- a/core/schema.go
+++ b/core/schema.go
@@ -1,8 +1,10 @@
-// schema.go
 package core
 
 import (
 	"fmt"
+	"regexp"
+	"strings"
+	"time"
 
 	"github.com/Relax-N-Tax/AgentNexus/types"
 )
@@ -10,12 +12,27 @@ import (
 type SchemaParser struct {
 	inputSchema  types.SchemaConfig
 	outputSchema types.SchemaConfig
+	defs         map[string]types.SchemaConfig // Store resolved $defs for reference
 }
 
 func NewSchemaParser(action types.Action) *SchemaParser {
+	// Extract all $defs from input and output schemas
+	defs := make(map[string]types.SchemaConfig)
+	if action.InputSchema.Defs != nil {
+		for name, def := range action.InputSchema.Defs {
+			defs[name] = def
+		}
+	}
+	if action.OutputSchema.Defs != nil {
+		for name, def := range action.OutputSchema.Defs {
+			defs[name] = def
+		}
+	}
+
 	return &SchemaParser{
 		inputSchema:  action.InputSchema,
 		outputSchema: action.OutputSchema,
+		defs:         defs,
 	}
 }
 
@@ -34,6 +51,20 @@ func (p *SchemaParser) ValidateResponse(response map[string]interface{}) error {
 }
 
 func (p *SchemaParser) validateSchema(data map[string]interface{}, schema types.SchemaConfig) error {
+	// Handle $ref if present
+	if schema.Ref != "" {
+		resolvedSchema, err := p.resolveRef(schema.Ref)
+		if err != nil {
+			return err
+		}
+		schema = resolvedSchema
+	}
+
+	// Validate type
+	if schema.Type != "" && !isValidType(schema.Type) {
+		return fmt.Errorf("invalid schema type: %s", schema.Type)
+	}
+
 	// Validate required fields
 	for _, field := range schema.Required {
 		if _, exists := data[field]; !exists {
@@ -41,6 +72,13 @@ func (p *SchemaParser) validateSchema(data map[string]interface{}, schema types.
 		}
 	}
 
+	// Validate additional properties if specified
+	if schema.AdditionalProperties != nil {
+		if err := p.validateAdditionalProperties(data, schema); err != nil {
+			return err
+		}
+	}
+
 	// Validate properties
 	return p.validateProperties(data, schema.Properties)
 }
@@ -61,7 +99,27 @@ func (p *SchemaParser) validateProperties(data map[string]interface{}, propertie
 
 func (p *SchemaParser) validateProperty(fieldName string, prop types.Property, value interface{}) error {
 	if value == nil {
-		return nil // Skip validation for nil values
+		return nil
+	}
+
+	// Handle $ref if present
+	if prop.Ref != "" {
+		resolvedSchema, err := p.resolveRef(prop.Ref)
+		if err != nil {
+			return err
+		}
+		return p.validateSchema(value.(map[string]interface{}), resolvedSchema)
+	}
+
+	// Handle anyOf, allOf, oneOf
+	if len(prop.AnyOf) > 0 {
+		return p.validateAnyOf(fieldName, prop.AnyOf, value)
+	}
+	if len(prop.AllOf) > 0 {
+		return p.validateAllOf(fieldName, prop.AllOf, value)
+	}
+	if len(prop.OneOf) > 0 {
+		return p.validateOneOf(fieldName, prop.OneOf, value)
 	}
 
 	switch prop.Type {
@@ -102,13 +160,79 @@ func (p *SchemaParser) validateObject(fieldName string, prop types.Property, val
 	return nil
 }
 
+func (p *SchemaParser) validateString(fieldName string, prop types.Property, value interface{}) error {
+	str, ok := value.(string)
+	if !ok {
+		return fmt.Errorf("field %s must be a string", fieldName)
+	}
+
+	// Validate enum
+	if len(prop.Enum) > 0 {
+		valid := false
+		for _, enumVal := range prop.Enum {
+			if str == enumVal {
+				valid = true
+				break
+			}
+		}
+		if !valid {
+			return fmt.Errorf("field %s must be one of %v", fieldName, prop.Enum)
+		}
+	}
+
+	// Validate const if specified
+	if prop.Const != "" && str != prop.Const {
+		return fmt.Errorf("field %s must be exactly %s", fieldName, prop.Const)
+	}
+
+	// Validate format
+	if prop.Format != "" {
+		if err := p.validateFormat(fieldName, prop.Format, str); err != nil {
+			return err
+		}
+	}
+
+	// Validate pattern
+	if prop.Pattern != "" {
+		matched, err := regexp.MatchString(prop.Pattern, str)
+		if err != nil {
+			return fmt.Errorf("invalid pattern in schema for field %s: %w", fieldName, err)
+		}
+		if !matched {
+			return fmt.Errorf("field %s does not match required pattern %s", fieldName, prop.Pattern)
+		}
+	}
+
+	return nil
+}
+
+func (p *SchemaParser) validateNumber(fieldName string, prop types.Property, value interface{}) error {
+	var num float64
+	switch v := value.(type) {
+	case float64:
+		num = v
+	case int:
+		num = float64(v)
+	default:
+		return fmt.Errorf("field %s must be a number", fieldName)
+	}
+
+	if prop.Minimum != nil && num < *prop.Minimum {
+		return fmt.Errorf("field %s must be greater than or equal to %v", fieldName, *prop.Minimum)
+	}
+	if prop.Maximum != nil && num > *prop.Maximum {
+		return fmt.Errorf("field %s must be less than or equal to %v", fieldName, *prop.Maximum)
+	}
+
+	return nil
+}
+
 func (p *SchemaParser) validateArray(fieldName string, prop types.Property, value interface{}) error {
 	arr, ok := value.([]interface{})
 	if !ok {
 		return fmt.Errorf("field %s must be an array", fieldName)
 	}
 
-	// Validate array length constraints
 	if prop.MinimumItems > 0 && len(arr) < prop.MinimumItems {
 		return fmt.Errorf("array %s must have at least %d items", fieldName, prop.MinimumItems)
 	}
@@ -116,7 +240,6 @@ func (p *SchemaParser) validateArray(fieldName string, prop types.Property, valu
 		return fmt.Errorf("array %s must have at most %d items", fieldName, prop.MaximumItems)
 	}
 
-	// Validate array items if items schema is provided
 	if prop.Items != nil {
 		for i, item := range arr {
 			if err := p.validateProperty(fmt.Sprintf("%s[%d]", fieldName, i), *prop.Items, item); err != nil {
@@ -128,49 +251,120 @@ func (p *SchemaParser) validateArray(fieldName string, prop types.Property, valu
 	return nil
 }
 
-func (p *SchemaParser) validateString(fieldName string, prop types.Property, value interface{}) error {
-	str, ok := value.(string)
-	if !ok {
-		return fmt.Errorf("field %s must be a string", fieldName)
+func (p *SchemaParser) validateBoolean(fieldName string, _ types.Property, value interface{}) error {
+	if _, ok := value.(bool); !ok {
+		return fmt.Errorf("field %s must be a boolean", fieldName)
 	}
-
-	// Validate enum if specified
-	if len(prop.Enum) > 0 {
-		valid := false
-		for _, enumVal := range prop.Enum {
-			if str == enumVal {
-				valid = true
-				break
-			}
+	return nil
+}
+func (p *SchemaParser) validateFormat(fieldName, format, value string) error {
+	switch format {
+	case "date-time":
+		_, err := time.Parse(time.RFC3339, value)
+		if err != nil {
+			return fmt.Errorf("field %s must be a valid RFC3339 date-time", fieldName)
 		}
-		if !valid {
-			return fmt.Errorf("field %s must be one of %v", fieldName, prop.Enum)
+	case "email":
+		if !isValidEmail(value) {
+			return fmt.Errorf("field %s must be a valid email address", fieldName)
+		}
+	case "uri":
+		if !isValidURI(value) {
+			return fmt.Errorf("field %s must be a valid URI", fieldName)
 		}
 	}
+	return nil
+}
 
-	// Add pattern validation if needed
-	if prop.Pattern != "" {
-		// You could add regex pattern validation here
+func (p *SchemaParser) resolveRef(ref string) (types.SchemaConfig, error) {
+	// Remove the #/$defs/ prefix
+	defName := strings.TrimPrefix(ref, "#/$defs/")
+	schema, exists := p.defs[defName]
+	if !exists {
+		return types.SchemaConfig{}, fmt.Errorf("undefined $ref: %s", ref)
 	}
+	return schema, nil
+}
+
+func (p *SchemaParser) validateAnyOf(fieldName string, schemas []types.Property, value interface{}) error {
+	var errors []string
+	for _, schema := range schemas {
+		if err := p.validateProperty(fieldName, schema, value); err == nil {
+			return nil
+		} else {
+			errors = append(errors, err.Error())
+		}
+	}
+	return fmt.Errorf("field %s failed to match any schema: %s", fieldName, strings.Join(errors, "; "))
+}
 
+func (p *SchemaParser) validateAllOf(fieldName string, schemas []types.Property, value interface{}) error {
+	for _, schema := range schemas {
+		if err := p.validateProperty(fieldName, schema, value); err != nil {
+			return err
+		}
+	}
 	return nil
 }
 
-func (p *SchemaParser) validateNumber(fieldName string, _ types.Property, value interface{}) error {
-	// Handle both float64 and int
-	switch value.(type) {
-	case float64:
-		return nil // Add any float-specific validations here
-	case int:
-		return nil // Add any int-specific validations here
-	default:
-		return fmt.Errorf("field %s must be a number", fieldName)
+func (p *SchemaParser) validateOneOf(fieldName string, schemas []types.Property, value interface{}) error {
+	validCount := 0
+	var lastError error
+	for _, schema := range schemas {
+		if err := p.validateProperty(fieldName, schema, value); err == nil {
+			validCount++
+		} else {
+			lastError = err
+		}
+	}
+	if validCount == 1 {
+		return nil
+	}
+	if validCount == 0 {
+		return fmt.Errorf("field %s did not match any schema: %v", fieldName, lastError)
 	}
+	return fmt.Errorf("field %s matched multiple schemas when exactly one was required", fieldName)
 }
 
-func (p *SchemaParser) validateBoolean(fieldName string, _ types.Property, value interface{}) error {
-	if _, ok := value.(bool); !ok {
-		return fmt.Errorf("field %s must be a boolean", fieldName)
+func (p *SchemaParser) validateAdditionalProperties(data map[string]interface{}, schema types.SchemaConfig) error {
+	for fieldName, value := range data {
+		// Skip fields that are defined in properties
+		if _, exists := schema.Properties[fieldName]; exists {
+			continue
+		}
+
+		if err := p.validateProperty(fieldName, *schema.AdditionalProperties, value); err != nil {
+			return fmt.Errorf("additional property validation failed for field %s: %w", fieldName, err)
+		}
 	}
 	return nil
 }
+
+// Helper functions
+
+func isValidType(t string) bool {
+	validTypes := map[string]bool{
+		"string":  true,
+		"number":  true,
+		"integer": true,
+		"boolean": true,
+		"array":   true,
+		"object":  true,
+		"null":    true,
+	}
+	return validTypes[t]
+}
+
+func isValidEmail(email string) bool {
+	// Basic email validation - could be made more sophisticated
+	pattern := `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
+	matched, err := regexp.MatchString(pattern, email)
+	return err == nil && matched
+}
+
+func isValidURI(uri string) bool {
+	// Basic URI validation - could be made more sophisticated
+	pattern := `^[a-zA-Z][a-zA-Z0-9+.-]*://`
+	matched, err := regexp.MatchString(pattern, uri)
+	return err == nil && matched
+}
diff --git a/internal/agents/payload_agent.go b/internal/agents/payload_agent.go
index 5b8f838..83331ea 100644
--- a/internal/agents/payload_agent.go
+++ b/internal/agents/payload_agent.go
@@ -26,29 +26,28 @@ var (
 	once     sync.Once
 )
 
-const payloadPromptTemplate = `System Message:
-You are a JSON schema expert. Create a payload that exactly matches this schema:
+const payloadPromptTemplate = `Create a payload matching this schema considering the task *context*:
 
-Schema Details:
-{{.schemaStr}}
+Schema: {{.schemaStr}}
 
-Task Context:
-{{- if .taskContext}}
-{{.taskContext}}
-{{- end}}
+Type Details:
+{{.typeDetails}}
+
+Constraints:
+{{.constraints}}
+
+{{if .taskContext}}Context:
+{{.taskContext}}{{end}}
 
 Example:
 {{.exampleStr}}
 
 IMPORTANT:
-- Return ONLY a valid JSON object
-- All values must match their defined types exactly
-- Arrays must contain items of the correct type
-- Include all required fields
-- Follow any format/pattern requirements
-- Respect enum value restrictions
-
-Response format: JSON object only.`
+- Return valid JSON only
+- Arrays must use [] even for single items
+- Required fields: {{.requiredFields}}
+- Follow all type constraints and patterns
+- Respect enums and const values`
 
 func GetPayloadAgent(ctx context.Context, config types.InternalAgentConfig) (*PayloadAgent, error) {
 	once.Do(func() {
@@ -86,27 +85,28 @@ func initializePayloadAgent(config types.InternalAgentConfig) *PayloadAgent {
 	}
 }
 
-func (a *PayloadAgent) GeneratePayload(ctx context.Context, task *types.Task, action types.Action) ([]byte, error) {
-	schemaInfo := formatSchema(action.InputSchema)
-	example := generateExample(action.InputSchema, task)
-	taskContext := generateTaskContext(task)
+func (p *PayloadAgent) GeneratePayload(ctx context.Context, task *types.Task, action types.Action) ([]byte, error) {
+	// Extract defs from schema
+	defs := make(map[string]types.SchemaConfig)
+	if action.InputSchema.Defs != nil {
+		defs = action.InputSchema.Defs
+	}
 
 	promptData := map[string]interface{}{
-		"schemaStr":   schemaInfo,
-		"exampleStr":  string(example),
-		"taskContext": taskContext,
+		"schemaStr":      formatSchema(action.InputSchema),
+		"typeDetails":    formatTypeDetails(action.InputSchema, defs),
+		"constraints":    formatConstraints(action.InputSchema),
+		"requiredFields": strings.Join(action.InputSchema.Required, ", "),
+		"taskContext":    generateTaskContext(task),
+		"exampleStr":     string(generateExample(action.InputSchema, task)),
 	}
 
-	prompt, err := a.promptMgr.GeneratePrompt("payloadPrompt", promptData)
+	prompt, err := p.promptMgr.GeneratePrompt("payloadPrompt", promptData)
 	if err != nil {
 		return nil, fmt.Errorf("generating prompt: %w", err)
 	}
 
-	if Debug {
-		log.Printf("Generated prompt:\n%s\n", prompt)
-	}
-
-	completion, err := getCompletionWithRetries(ctx, a.llmClient, prompt)
+	completion, err := getCompletionWithRetries(ctx, p.llmClient, prompt)
 	if err != nil {
 		return nil, err
 	}
@@ -117,24 +117,7 @@ func (a *PayloadAgent) GeneratePayload(ctx context.Context, task *types.Task, ac
 func formatSchema(schema types.SchemaConfig) string {
 	var b strings.Builder
 	b.WriteString(fmt.Sprintf("Type: %s\n", schema.Type))
-	if schema.Description != "" {
-		b.WriteString(fmt.Sprintf("Description: %s\n", schema.Description))
-	}
-
-	if len(schema.Required) > 0 {
-		b.WriteString("\nRequired Fields:\n")
-		for _, field := range schema.Required {
-			prop := schema.Properties[field]
-			formatProperty(&b, field, prop, true)
-		}
-	}
-
-	for name, prop := range schema.Properties {
-		if !contains(schema.Required, name) {
-			formatProperty(&b, name, prop, false)
-		}
-	}
-
+	b.WriteString(fmt.Sprintf("Description: %s\n", schema.Description))
 	return b.String()
 }
 
@@ -179,6 +162,199 @@ func formatProperty(b *strings.Builder, name string, prop types.Property, requir
 	}
 }
 
+func formatTypeDetails(schema types.SchemaConfig, defs map[string]types.SchemaConfig) string {
+	var b strings.Builder
+
+	for name, prop := range schema.Properties {
+		b.WriteString(fmt.Sprintf("\n%s:\n", name))
+		if prop.Ref != "" {
+			if def, ok := resolveRef(prop.Ref, defs); ok {
+				writeSchemaDetails(&b, def, "  ", defs)
+			}
+		} else if prop.AnyOf != nil {
+			b.WriteString("  AnyOf:\n")
+			for _, subProp := range prop.AnyOf {
+				if subProp.Ref != "" {
+					if def, ok := resolveRef(subProp.Ref, defs); ok {
+						writeSchemaDetails(&b, def, "    ", defs)
+					}
+				} else {
+					writePropertyDetails(&b, subProp, "    ", defs)
+				}
+			}
+		} else {
+			writePropertyDetails(&b, prop, "  ", defs)
+		}
+	}
+	return b.String()
+}
+
+func writeSchemaDetails(b *strings.Builder, schema types.SchemaConfig, indent string, defs map[string]types.SchemaConfig) {
+	b.WriteString(fmt.Sprintf("%sType: %s\n", indent, schema.Type))
+	if schema.Description != "" {
+		b.WriteString(fmt.Sprintf("%sDescription: %s\n", indent, schema.Description))
+	}
+	if len(schema.Properties) > 0 {
+		b.WriteString(fmt.Sprintf("%sProperties:\n", indent))
+		for name, prop := range schema.Properties {
+			b.WriteString(fmt.Sprintf("%s  %s:\n", indent, name))
+			writePropertyDetails(b, prop, indent+"    ", defs)
+		}
+	}
+	if len(schema.Required) > 0 {
+		b.WriteString(fmt.Sprintf("%sRequired: [%s]\n", indent, strings.Join(schema.Required, ", ")))
+	}
+}
+
+func writePropertyDetails(b *strings.Builder, prop types.Property, indent string, defs map[string]types.SchemaConfig) {
+	b.WriteString(fmt.Sprintf("%sType: %s\n", indent, prop.Type))
+
+	if prop.Const != "" {
+		b.WriteString(fmt.Sprintf("%sConst: %s\n", indent, prop.Const))
+	}
+	if len(prop.Enum) > 0 {
+		b.WriteString(fmt.Sprintf("%sEnum: [%s]\n", indent, strings.Join(prop.Enum, ", ")))
+	}
+	if prop.Default != nil {
+		b.WriteString(fmt.Sprintf("%sDefault: %v\n", indent, prop.Default))
+	}
+	if prop.Type == "array" && prop.Items != nil {
+		b.WriteString(fmt.Sprintf("%sArray items:\n", indent))
+		writePropertyDetails(b, *prop.Items, indent+"  ", defs)
+	}
+}
+
+func formatPropertyDetails(b *strings.Builder, prop types.Property, indent string, defs map[string]types.SchemaConfig) {
+	b.WriteString(fmt.Sprintf("%sType: %s\n", indent, prop.Type))
+
+	if prop.Const != "" {
+		b.WriteString(fmt.Sprintf("%sConst: %s\n", indent, prop.Const))
+	}
+
+	if len(prop.Enum) > 0 {
+		b.WriteString(fmt.Sprintf("%sEnum: [%s]\n", indent, strings.Join(prop.Enum, ", ")))
+	}
+
+	if prop.Default != nil {
+		b.WriteString(fmt.Sprintf("%sDefault: %v\n", indent, prop.Default))
+	}
+
+	if prop.Type == "object" && len(prop.Properties) > 0 {
+		b.WriteString(fmt.Sprintf("%sProperties:\n", indent))
+		for name, subProp := range prop.Properties {
+			b.WriteString(fmt.Sprintf("%s  %s:\n", indent, name))
+			formatPropertyDetails(b, subProp, indent+"    ", defs)
+		}
+		if len(prop.Required) > 0 {
+			b.WriteString(fmt.Sprintf("%s  Required: [%s]\n", indent, strings.Join(prop.Required, ", ")))
+		}
+	}
+
+	if prop.Type == "array" && prop.Items != nil {
+		b.WriteString(fmt.Sprintf("%sArray items:\n", indent))
+		formatPropertyDetails(b, *prop.Items, indent+"  ", defs)
+	}
+}
+
+func resolveRef(ref string, defs map[string]types.SchemaConfig) (types.SchemaConfig, bool) {
+	parts := strings.Split(strings.TrimPrefix(ref, "#/$defs/"), "/")
+	if len(parts) > 0 {
+		if def, ok := defs[parts[len(parts)-1]]; ok {
+			return def, true
+		}
+	}
+	return types.SchemaConfig{}, false
+}
+
+func formatValidationConstraints(b *strings.Builder, prop types.Property, indent string) {
+	if prop.Pattern != "" {
+		b.WriteString(fmt.Sprintf("%sPattern: %s\n", indent, prop.Pattern))
+	}
+	if prop.Minimum != nil {
+		b.WriteString(fmt.Sprintf("%sMin: %v\n", indent, *prop.Minimum))
+	}
+	if prop.Maximum != nil {
+		b.WriteString(fmt.Sprintf("%sMax: %v\n", indent, *prop.Maximum))
+	}
+	if prop.MinimumItems > 0 {
+		b.WriteString(fmt.Sprintf("%sMin items: %d\n", indent, prop.MinimumItems))
+	}
+	if prop.MaximumItems > 0 {
+		b.WriteString(fmt.Sprintf("%sMax items: %d\n", indent, prop.MaximumItems))
+	}
+}
+
+func formatConstraints(schema types.SchemaConfig) string {
+	var b strings.Builder
+	formatSchemaConstraints(&b, schema, "", make(map[string]bool))
+	return b.String()
+}
+
+func formatSchemaConstraints(b *strings.Builder, schema types.SchemaConfig, prefix string, visited map[string]bool) {
+	for name, prop := range schema.Properties {
+		fullName := prefix + name
+		if visited[fullName] {
+			continue
+		}
+		visited[fullName] = true
+
+		if prop.Pattern != "" || prop.Minimum != nil || prop.Maximum != nil ||
+			prop.MinimumItems > 0 || prop.MaximumItems > 0 {
+			b.WriteString(fmt.Sprintf("\n%s:\n", fullName))
+			formatValidationConstraints(b, prop, "  ")
+		}
+
+		// Recurse into nested objects
+		if prop.Type == "object" && len(prop.Properties) > 0 {
+			formatSchemaConstraints(b, types.SchemaConfig{Properties: prop.Properties}, fullName+".", visited)
+		}
+	}
+}
+
+func formatArrayInfo(schema types.SchemaConfig) string {
+	var b strings.Builder
+	b.WriteString("Array fields must be enclosed in [] even for single values:\n")
+
+	for name, prop := range schema.Properties {
+		if prop.Type == "array" {
+			b.WriteString(fmt.Sprintf("- %s: ", name))
+			if prop.Items != nil {
+				b.WriteString(fmt.Sprintf("array of %s", prop.Items.Type))
+				if len(prop.Items.Enum) > 0 {
+					b.WriteString(fmt.Sprintf(" (allowed values: %s)", strings.Join(prop.Items.Enum, ", ")))
+				}
+			}
+			b.WriteString("\n")
+		}
+	}
+	return b.String()
+}
+
+func formatTypeConstraints(schema types.SchemaConfig) string {
+	var b strings.Builder
+	for name, prop := range schema.Properties {
+		if prop.Minimum != nil || prop.Maximum != nil || prop.MinimumItems > 0 || prop.MaximumItems > 0 || prop.Pattern != "" {
+			b.WriteString(fmt.Sprintf("\nField '%s' constraints:\n", name))
+			if prop.Minimum != nil {
+				b.WriteString(fmt.Sprintf("- Minimum: %v\n", *prop.Minimum))
+			}
+			if prop.Maximum != nil {
+				b.WriteString(fmt.Sprintf("- Maximum: %v\n", *prop.Maximum))
+			}
+			if prop.MinimumItems > 0 {
+				b.WriteString(fmt.Sprintf("- Minimum items: %d\n", prop.MinimumItems))
+			}
+			if prop.MaximumItems > 0 {
+				b.WriteString(fmt.Sprintf("- Maximum items: %d\n", prop.MaximumItems))
+			}
+			if prop.Pattern != "" {
+				b.WriteString(fmt.Sprintf("- Must match pattern: %s\n", prop.Pattern))
+			}
+		}
+	}
+	return b.String()
+}
+
 func generateExample(schema types.SchemaConfig, task *types.Task) []byte {
 	if len(schema.Examples) > 0 {
 		if example, err := json.MarshalIndent(schema.Examples[0], "", "  "); err == nil {
@@ -380,41 +556,82 @@ IMPORTANT:
 Response format: JSON object only.`
 
 // Add these methods to PayloadAgent struct
+// In payload_agent.go
 func (a *PayloadAgent) GeneratePayloadWithRetry(ctx context.Context, task *types.Task, action types.Action) ([]byte, error) {
-	payload, err := a.GeneratePayload(ctx, task, action)
-	if err != nil {
-		return nil, err
-	}
+	var payload []byte
+	var err error
+	maxRetries := 3
+
+	for attempt := 0; attempt < maxRetries; attempt++ {
+		if attempt > 0 {
+			log.Printf("Retry attempt %d/%d for generating payload for task %s", attempt+1, maxRetries, task.ID)
+			time.Sleep(time.Duration(attempt) * time.Second)
+		}
 
-	// Try to send the payload to the endpoint (we'll need the URL and method from the action)
-	client := &http.Client{Timeout: 30 * time.Second}
-	url := fmt.Sprintf("%s%s", action.Name, action.Path)
+		// Generate initial payload
+		payload, err = a.GeneratePayload(ctx, task, action)
+		if err != nil {
+			log.Printf("Error generating payload on attempt %d: %v", attempt+1, err)
+			continue
+		}
 
-	req, err := http.NewRequestWithContext(ctx, action.Method, url, bytes.NewBuffer(payload))
-	if err != nil {
-		return nil, fmt.Errorf("creating request: %w", err)
-	}
+		// Validate payload against schema before sending
+		var reqBody map[string]interface{}
+		if err := json.Unmarshal(payload, &reqBody); err != nil {
+			log.Printf("Invalid JSON payload on attempt %d: %v", attempt+1, err)
+			continue
+		}
 
-	req.Header.Set("Content-Type", "application/json")
+		// Try to send the payload to the endpoint
+		client := &http.Client{Timeout: 30 * time.Second}
 
-	resp, err := client.Do(req)
-	if err != nil {
-		return nil, err
-	}
-	defer resp.Body.Close()
+		// Format URL properly
+		baseURL := strings.TrimRight(action.BaseURL, "/")
+		path := "/" + strings.TrimLeft(action.Path, "/")
+		url := baseURL + path
+
+		req, err := http.NewRequestWithContext(ctx, action.Method, url, bytes.NewBuffer(payload))
+		if err != nil {
+			return nil, fmt.Errorf("creating request: %w", err)
+		}
+
+		req.Header.Set("Content-Type", "application/json")
 
-	// If we get a 422 (Validation Error), try to fix the payload
-	if resp.StatusCode == http.StatusUnprocessableEntity {
+		resp, err := client.Do(req)
+		if err != nil {
+			log.Printf("Error sending request on attempt %d: %v", attempt+1, err)
+			continue
+		}
+
+		// Read response body
 		body, err := io.ReadAll(resp.Body)
+		resp.Body.Close()
+
 		if err != nil {
-			return nil, fmt.Errorf("reading error response: %w", err)
+			log.Printf("Error reading response body on attempt %d: %v", attempt+1, err)
+			continue
 		}
 
-		// Try to fix the payload with the validation errors
-		return a.fixPayloadWithErrors(ctx, task, action, payload, body)
+		// Handle different response status codes
+		switch resp.StatusCode {
+		case http.StatusOK:
+			return payload, nil
+		case http.StatusUnprocessableEntity:
+			log.Printf("Validation error on attempt %d, trying to fix payload", attempt+1)
+			// Try to fix the payload with the validation errors
+			if fixedPayload, err := a.fixPayloadWithErrors(ctx, task, action, payload, body); err == nil {
+				return fixedPayload, nil
+			}
+		default:
+			log.Printf("Unexpected status code %d on attempt %d", resp.StatusCode, attempt+1)
+		}
+	}
+
+	if err != nil {
+		return nil, fmt.Errorf("failed after %d attempts: %w", maxRetries, err)
 	}
 
-	return payload, nil
+	return nil, fmt.Errorf("failed to generate valid payload after %d attempts", maxRetries)
 }
 
 func (a *PayloadAgent) fixPayloadWithErrors(ctx context.Context, task *types.Task, action types.Action, previousPayload []byte, errorBody []byte) ([]byte, error) {
diff --git a/types/types.go b/types/types.go
index 5e62282..41a2f96 100644
--- a/types/types.go
+++ b/types/types.go
@@ -32,36 +32,50 @@ type Capability struct {
 }
 
 type Action struct {
-	Name         string       `json:"name"`
+	Name         string `json:"name"`
+	BaseURL      string
 	Path         string       `json:"path"`
 	Method       string       `json:"method"`
 	InputSchema  SchemaConfig `json:"inputSchema"`
 	OutputSchema SchemaConfig `json:"outputSchema"`
 }
+
 type SchemaConfig struct {
-	Type                 string              `json:"type"`
-	Required             []string            `json:"required,omitempty"`
-	Properties           map[string]Property `json:"properties,omitempty"`
-	AdditionalProperties interface{}         `json:"additionalProperties,omitempty"`
-	Description          string              `json:"description,omitempty"`
-	Example              interface{}         `json:"example,omitempty"`
-	Examples             []interface{}       `json:"examples,omitempty"`
+	Type                 string                  `json:"type"`
+	Required             []string                `json:"required,omitempty"`
+	Properties           map[string]Property     `json:"properties,omitempty"` // Changed from SchemaProperty to Property
+	Description          string                  `json:"description,omitempty"`
+	Title                string                  `json:"title,omitempty"`
+	Defs                 map[string]SchemaConfig `json:"$defs,omitempty"`
+	Ref                  string                  `json:"$ref,omitempty"`
+	AdditionalProperties *Property               `json:"additionalProperties,omitempty"` // Changed from SchemaProperty to Property
+	Default              interface{}             `json:"default,omitempty"`
+	Examples             []interface{}           `json:"examples,omitempty"` // Added Examples field
+	Example              interface{}             `json:"example,omitempty"`  // Added Example field
 }
-
 type Property struct {
 	Type                 string              `json:"type"`
-	Formats              []string            `json:"formats,omitempty"`
-	MaxSize              string              `json:"max_size,omitempty"`
-	Enum                 []string            `json:"enum,omitempty"`
+	Title                string              `json:"title,omitempty"`
+	Description          string              `json:"description,omitempty"`
+	Format               string              `json:"format,omitempty"`
+	Pattern              string              `json:"pattern,omitempty"` // Added Pattern field
 	Default              interface{}         `json:"default,omitempty"`
-	Items                *Property           `json:"items,omitempty"`      // For array types
-	Properties           map[string]Property `json:"properties,omitempty"` // For object types
+	Enum                 []string            `json:"enum,omitempty"`
+	Const                string              `json:"const,omitempty"`
+	Items                *Property           `json:"items,omitempty"`
+	Properties           map[string]Property `json:"properties,omitempty"`
 	Required             []string            `json:"required,omitempty"`
 	MinimumItems         int                 `json:"minItems,omitempty"`
 	MaximumItems         int                 `json:"maxItems,omitempty"`
-	Pattern              string              `json:"pattern,omitempty"`
-	Format               string              `json:"format,omitempty"`
-	AdditionalProperties interface{}         `json:"additionalProperties,omitempty"`
+	Minimum              *float64            `json:"minimum,omitempty"`
+	Maximum              *float64            `json:"maximum,omitempty"`
+	AnyOf                []Property          `json:"anyOf,omitempty"`
+	AllOf                []Property          `json:"allOf,omitempty"`
+	OneOf                []Property          `json:"oneOf,omitempty"`
+	Ref                  string              `json:"$ref,omitempty"`
+	AdditionalProperties *Property           `json:"additionalProperties,omitempty"`
+	Examples             []interface{}       `json:"examples,omitempty"`
+	Example              interface{}         `json:"example,omitempty"`
 }
 
 const (
